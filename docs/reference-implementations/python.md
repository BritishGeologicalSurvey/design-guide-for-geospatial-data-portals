# Python Implementations

## BGS Index and Meta data API template 

(LINK to GIT REPOSITRY)

For simple APIs serving BGS data where:
* Data is in a DB Query Layer (with maybe a couple of dictionaries)
* The Query Layer is an index of maps/reports/rocks/fossils/...
* Each item has relatively few simple properties
* Each item optionally has a link to an external resource (e.g. large image viewer or PDF download)
* API provides only "search", "full details" and "dictionary (dropdown)" endpoints

## Time series and Sensor data

(LINK to GIT REPOSITRY)

TODO

## Pydantic

Using Pydantic when developing an API service that returns data in JSON format has several advantages. Python has made improvements with static type checking and Pydantic builds on this to enforce type checking dynamically. In the case of an API, when each endpoint is requested, the response will be validated against a Pydantic model. This effectivly acts as a contract for the API request responses. 

```
class TypeStatus(BaseModel):
    CODE: str = Field(..., example="Something")
    TRANSLATION: str = Field(..., example="Something else")
    DESCRIPTION: str = Field(..., example="A type of thing")
```

Pydantic is integrated with OpenAPI. In the above example a Pydantic model is defined when a class TypeStatus inherits Pydantics BaseModel. Declared are the attributes and their type (Pydantic comes with a huge set of types see [here](https://pydantic-docs.helpmanual.io/usage/types/)). Pydantics Field class can be used to provide information to be displayed on the OpenAPI schema generated by FastAPI. 

```
class MinimalResponse(BaseModel):
    msg: str
    type: str
    self: str

class TypeStatusResponse(MinimalResponse):
    data: List[TypeStatus] = []
```

Pydantic models can also be contained in a list as shown in the TypeStatusResponse model.


```
@router.get(
    config.get_config().BASE_PATH + "/vocab/type_statuses",
    response_model=TypeStatusResponse
)
def get_vocab_type_statuses(request: Request, config: config.AppConfig = Depends(config.get_config)):
    """Process endpoint request"""
    
    ...
    
    return response
   
```
[add image of schema in docs]

Each each endpoint has a response_model parameter and can assign a Pydantic model to convert and validate the endpoints output to its declared type in the model. The integration with OpenAPI means response model will add a JSON schema to the paths responses in the auto generated docs. 



After extracting data from a database the rows can be converted to a Pydantic model at the same time limiting the data to the attributes declared in the model by excluding those attributes/values in the row object not declared in the model. Below the parse_results function unpacks the values in each row into a TypeStatus model. 


```
def parse_results(rows):
     return [TypeStatus(**row) for row in rows]
```
